# RUST标准库内存模块代码分析
内存模块的代码路径举例如下(以作者电脑上的路径):
%USER%\.rustup\toolchains\nightly-x86_64-pc-windows-msvc\lib\rustlib\src\rust\library\core\src\alloc\*.*
%USER%\.rustup\toolchains\nightly-x86_64-pc-windows-msvc\lib\rustlib\src\rust\library\core\src\ptr\*.*
%USER%\.rustup\toolchains\nightly-x86_64-pc-windows-msvc\lib\rustlib\src\rust\library\core\src\mem\*.*
%USER%\.rustup\toolchains\nightly-x86_64-pc-windows-msvc\lib\rustlib\src\rust\library\core\src\intrinsic.rs
%USER%\.rustup\toolchains\nightly-x86_64-pc-windows-msvc\lib\rustlib\src\rust\library\alloc\src\alloc.rs

RUST之所以被认为难学，是因为RUST与C相同，需要对内存做彻底的控制，即程序可以在代码中编写专属内存管理系统，并将内存管理系统与语言类型相关联，在内存块与语言类型之间做自如的转换。对于当前现代语法的高级语言如Java/Python/JS/Go，内存管理是编译器的任务，这就导致大部分程序员对于内存管理缺乏经验，所以对RUST内存安全相关的所有权/生命周期等缺乏实践认知。相对于C，RUST的现代语法特性及内存安全导致RUST的内存块与类型系统的转换的细节非常复杂，不容易被透彻理解。本节将从标准库的内存模块的代码分析中给出RUST内存的本质。理解了RUST内存及内存安全，RUST语言的最难关便过了。

从内存角度考察一个变量，则每个变量具备统一的内存参数，这些参数是：
1. 变量的首地址，是一个usize的数值
2. 变量类型占用的内存块大小
3. 变量类型内存字节对齐的基数
4. 变量类型中成员内存顺序  

如果变量成员是复合类型，可递归上面的四个参数。 
RUST认为变量类型成员顺序与编译优化不可分割，因此，变量成员内存顺序完全由编译器控制，这与C不同，C中变量类型成员的顺序是不能被编译器改动的。这使得C变量的内存布局对程序员是透明的。这种透明性导致了C语言在设计类型内存布局的操作中会出现很多坏代码。如，直接用头指针+偏移数值来获得类型内部变量的指针，直接导致变量类型可修改性极差。  
与C相同，RUST具备将一块内存块直接转换成某一类型变量的能力。这一能力是RUST操作系统内核编程及高效的一个基石。但因为这个转换使得代码可以绕过编译器的类型系统检查，造成了BUG也绕过了编译器的某些错误检查，而这些错误很可能在系统运行很久之后才真正的出错，造成排错的极高成本。  
GC类语言去掉了这一能力，但也牺牲了性能，且无法作为系统级别语言。RUST没有因噎废食，在保留能力的同时给出这一能力明确的危险标识unsafe, 加上整体的内存安全框架设计，使得此类错误更易被发现，更易被定位，极大的降低了错误的数目及排错的成本。  
unsafe容易让初学RUST语言的程序员产生排斥感，但unsafe实际上是RUST不可分割的部分，一个好的RUST程序员绝不是不使用unsafe，而是能够准确的把握好unsafe使用的合适场合及合适范围，必要的时候必须使用，但不滥用。

掌握RUST的内存，主要有如下几个部分： 
1. 编译器提供的固有内存操作函数  
2. 内存块与类型系统的结合点：裸指针 `*const T/*mut T`  
3. 裸指针的包装结构: `NonNull<T>/Unique<T>`  
4. 未初始化内存块的处理：`MaybeUninit<T>/ManuallyDrop<T>`  
5. 堆内存申请及释放  
   
## 裸指针标准库代码分析
裸指针`*const T/* mut T`将内存和类型系统相连接，*const T代表了一个内存块，指示了内存块首地址，大小，对齐等属性，以及后文提到的元数据，但不保证这个内存块的有效性和安全性。  
与`*const T/* mut T`不同，`&T/&mut T`则保证内存块是安全和有效的，这表示`&T/&mut T`满足内存块首地址对齐，内存块已经完成了初始化。在RUST中，`&T/&mut T`是被绑定在某一内存块上，只能用于读写这一内存块。    
对于内存块更复杂的操作，由`*const T/*mut T` 负责，主要有：  
1. 将usize类型数值强制转换成裸指针类型，以此数值为首地址的内存块被转换为相应的类型。如果对这一转换后的内存块进行读写，可能造成内存安全问题。  
2. 在不同的裸指针类型之间进行强制转换，实质上完成了裸指针指向的内存块的类型强转，如果对这一转换后的内存块进行读写，可能造成内存安全问题。 
3. `*const u8`作为堆内存申请的内存块绑定变量  
4. 内存块置值操作，如清零或置一个魔术值  
5. 显式的内存块拷贝操作，某些情况下，内存块拷贝是必须的高性能方式。   
6. 利用指针偏移计算获取新的内存块， 在数组及切片访问，字符串，协议字节填写，文件缓存等都需要指针偏移计算。  
7. 从外部的C函数接口对接的指针参数  
8... 

RUST的裸指针类型不象C语言的指针类型那样仅仅是一个地址值，为满足实现内存安全的类型系统需求，并兼顾内存使用效率和方便性，RUST的裸指针实质是一个较复杂的类型结构体。

### 裸指针具体实现
`*const T/*mut T`实质是个数据结构体，由两个部分组成，第一个部分是一个内存地址，第二个部分对这个内存地址的约束性描述-元数据
```rust
//从下面结构定义可以看到，裸指针本质就是PtrComponents<T>
pub(crate) union PtrRepr<T: ?Sized> {
    pub(crate) const_ptr: *const T,
    pub(crate) mut_ptr: *mut T,
    pub(crate) components: PtrComponents<T>,
}

pub(crate) struct PtrComponents<T: ?Sized> {
    //*const ()保证元数据部分是空 
    pub(crate) data_address: *const (),
    //不同类型指针的元数据
    pub(crate) metadata: <T as Pointee>::Metadata,
}

//从下面Pointee的定义可以看到一个RUST的编程技巧，即Trait可以只用来实现对关联类型的指定，Pointee这一Trait即只用来指定Metadata的类型。
pub trait Pointee {
    /// The type for metadata in pointers and references to `Self`.
    type Metadata: Copy + Send + Sync + Ord + Hash + Unpin;
}
//廋指针元数据是单元类型，即是空
pub trait Thin = Pointee<Metadata = ()>;
```
元数据的规则:
* 对于固定大小类型的指针（实现了 `Sized` Trait）, RUST定义为廋指针(thin pointer)，元数据大小为0，类型为(),这里要注意，RUST中数组也是固定大小的类型，运行中对数组下标合法性的检测，就是比较是否已经越过了数组的内存大小。
* 对于动态大小类型的指针(DST 类型)，RUST定义为胖指针(fat pointer 或 wide pointer), 元数据为：  
    * 对于结构类型，如果最后一个成员是动态大小类型(结构的其他成员不允许为动态大小类型)，则元数据为此动态大小类型  
    的元数据  
    * 对于`str`类型, 元数据是按字节计算的长度值，元数据类型是usize  
    * 对于切片类型，例如`[T]`类型，元数据是数组元素的数目值，元数据类型是usize   
    * 对于trait对象，例如 dyn SomeTrait， 元数据是 [DynMetadata<Self>][DynMetadata]（后面代码解释）
    （例如：DynMetadata<dyn SomeTrait>)
随着RUST的发展，有可能会根据需要引入新的元数据种类。

在标准库代码当中没有指针类型如何实现Pointee Trait的代码，编译器针对每个类型自动的实现了Pointee。
如下为rust编译器代码的一个摘录
```rust
    pub fn ptr_metadata_ty(&'tcx self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {
        // FIXME: should this normalize?
        let tail = tcx.struct_tail_without_normalization(self);
        match tail.kind() {
            // Sized types
            ty::Infer(ty::IntVar(_) | ty::FloatVar(_))
            | ty::Uint(_)
            | ty::Int(_)
            | ty::Bool
            | ty::Float(_)
            | ty::FnDef(..)
            | ty::FnPtr(_)
            | ty::RawPtr(..)
            | ty::Char
            | ty::Ref(..)
            | ty::Generator(..)
            | ty::GeneratorWitness(..)
            | ty::Array(..)
            | ty::Closure(..)
            | ty::Never
            | ty::Error(_)
            | ty::Foreign(..)
            | ty::Adt(..)
            // 如果是固定类型，元数据是单元类型 tcx.types.unit，即为空
            | ty::Tuple(..) => tcx.types.unit,

            //对于字符串和切片类型，元数据为长度tcx.types.usize，是元素长度
            ty::Str | ty::Slice(_) => tcx.types.usize,

            //对于dyn Trait类型， 元数据从具体的DynMetadata获取*
            ty::Dynamic(..) => {
                let dyn_metadata = tcx.lang_items().dyn_metadata().unwrap();
                tcx.type_of(dyn_metadata).subst(tcx, &[tail.into()])
            },
            
            //以下类型不应有元数据
            ty::Projection(_)
            | ty::Param(_)
            | ty::Opaque(..)
            | ty::Infer(ty::TyVar(_))
            | ty::Bound(..)
            | ty::Placeholder(..)
            | ty::Infer(ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)) => {
                bug!("`ptr_metadata_ty` applied to unexpected type: {:?}", tail)
            }
        }
    }
```
以上代码中的中文注释比较清晰的说明了编译器对每一个类型（或类型指针）都实现了Pointee中元数据类型的获取。
对于Trait对象的元数据的具体结构定义见如下代码：
```rust
//dyn Trait裸指针的元数据结构
pub struct DynMetadata<Dyn: ?Sized> {
    //堆中的VTTable变量的引用,VTable见后面的说明
    vtable_ptr: &'static VTable,
    //标示结构对Dyn的所有权关系，
    //其中PhantomData与具体变量的联系在初始化时由编译器自行推断完成, 这里PhantomData主要对编译器做出
    //提示做Drop check时注意本结构体会负责对Dyn类型变量做drop。
    phantom: crate::marker::PhantomData<Dyn>,
}

struct VTable {
    //trait对象的drop方法的指针，这里trait对象是一个具体的结构体，它实现了trait
    drop_in_place: fn(*mut ()),
    //trait对象类型的内存大小
    size_of: usize,
    //trait对象类型的字节对齐大小
    align_of: usize,
    //后继是trait对象的所有方法的指针数组
}
```

元数据类型相同的裸指针可以任意的转换，例如：可以有 * const [usize; 3] as * const[usize; 5] 这种语句
元数据类型不同的裸指针之间不能转换，例如；* const [usize;3] as *const[usize] 这种语句无法通过编译器 

### 裸指针的操作函数——intrinsic模块内存相关固有函数
intrinsics模块中的函数由编译器内置实现，并提供给其他模块使用。固有函数标准库没有代码，所以对其主要是了解功能和如何使用，intrinsics模块的内存函数一般不由库以外的代码直接调用，而是由mem模块和ptr模块封装后再提供给其他模块。 

内存申请及释放函数：
`intrinsics::drop_in_place<T:Sized?>(to_drop: * mut T)` 在某些情况下，我们会主动的将变量设置成不允许编译器自动调用变量的drop函数， 此时如果仍然需要对变量调用drop，则在代码中显式调用此函数以出发对T类型的drop调用。  
`intrinsics::forget<T:Sized?> (_:T)`, 代码中调用这个函数后，编译器不对forget的变量自动调用变量的drop函数。 
`intrinsics::needs_drop<T>()->bool`, 判断T类型是否需要做drop操作，实现了Copy trait的类型会返回false  

类型转换：
`intrinsics::transmute<T,U>(e:T)->U`, 对于内存布局相同的类型 T和U, 完成将类型T变量转换为类型U变量，此时T的所有权将转换为U的所有权   

指针偏移函数:
`intrinsics::offset<T>(dst: *const T, offset: usize)->* const T`, 相当于C的类型指针加计算   
`intrinsics::ptr_offset_from<T>(ptr: *const T, base: *const T) -> isize` 基于类型T内存布局的两个裸指针之间的偏移量  

内存块内容修改函数:
`intrinsics::copy<T>(src:*const T, dst: *mut T, count:usize)`, 内存拷贝， src和dst内存可重叠， 类似c语言中的memmove, 此时dst原有内存如果已经初始化，则会出现内存泄漏。src的所有权实际会被复制，从而也造成重复drop问题。

`intrinsics::copy_no_overlapping<T>(src:*const T, dst: * mut T, count:usize)`, 内存拷贝， src和dst内存不重叠   

`intrinsics::write_bytes(dst: *mut T, val:u8, count:usize)` , C语言的memset的RUST实现, 此时，原内存如果已经初始化，则原内存的变量可能造成内存泄漏，且因为编译器会继续对dst的内存块做drop调用，有可能会UB。  

类型内存参数函数：
`intrinsics::size_of<T>()->usize` 类型内存空间字节大小  
`intrinsics::min_align_of<T>()->usize` 返回类型对齐字节大小  
`intrinsics::size_of_val<T>(_:*const T)->usize`返回指针指向的变量内存空间字节大小  
`intrinsics::min_align_of_val<T>(_: * const T)->usize` 返回指针指向的变量对齐字节大小  

禁止优化的内存函数：
形如`volatile_xxxx` 的函数是通知编译器不做内存优化的操作函数,一般硬件相关操作需要禁止优化。  
`intrinsics::volatile_copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: usize)` 内存拷贝  

`intrinsics::volatile_copy_memory<T>(dst: *mut T, src: *const T, count: usize)` 功能类似C语言memmove  

`intrinsics::volatile_set_memory<T>(dst: *mut T, val: u8, count: usize)`  功能类似C语言memset  

`intrinsics::volatile_load<T>(src: *const T) -> T`读取内存或寄存器，T类型字节对齐到2的幂次

`intrinsics::volatile_store<T>(dst: *mut T, val: T)`内存或寄存器写入，字节对齐  

`intrinsics::unaligned_volatile_load<T>(src: *const T) -> T` 字节非对齐  

`intrinsics::unaligned_volatile_store<T>(dst: *mut T, val: T)`字节非对齐  

内存比较函数：
`intrinsics::raw_eq<T>(a: &T, b: &T) -> bool` 内存比较，类似C语言memcmp  

`pub fn ptr_guaranteed_eq<T>(ptr: *const T, other: *const T) -> bool` 判断两个指针是否判断, 相等返回ture, 不等返回false  

`pub fn ptr_guaranteed_ne<T>(ptr: *const T, other: *const T) -> bool` 判断两个指针是否不等，不等返回true  

### 裸指针方法
RUST针对`*const T/*mut T`的类型实现了若干方法，是对语言的原生类型实现方法，并扩展的实例：
```rust
impl <T:?Sized> * const T {
    ...
}
impl <T:?Sized> *mut T{
    ...
}
impl <T> *const [T] {
    ...
}
impl <T> *mut [T] {
    ...
}
```
对于裸指针，RUST标准库包含了最基础的 `* const T/* mut T`， 以及在`* const T/*mut T` 基础上特化的切片类型[T]的裸指针`* const [T]/*mut [T]`。
标准库针对这两种类型实现了一些关联函数及方法。这里一定注意，所有针对 `* const T`的方法在`* const [T]`上都是适用的。

以上有几点值得注意：
1. 可以针对原生类型实现方法(实现trait)，这体现了RUST类型系统的强大扩展性，也是对函数式编程的强大支持
2. 针对泛型约束实现方法，我们可以大致认为`*const T/* mut T`实质是一种泛型约束，`*const [T]/*mut [T]`是更进一步的约束，这使得RUST可以具备更好的数据抽象能力，简化代码，复用模块。

#### 裸指针的创建
直接从已经初始化的变量创建裸指针：
```rust
    &T as *const T;
    &mut T as * mut T;
```
直接用usize的数值创建裸指针：
```rust
    {
        let  a: usize = 0xf000000000000000;
        unsafe {a as * const i32};
    }
```
操作系统内核经常需要直接将一个地址数值转换为某一类型的裸指针

RUST也提供了一些其他的裸指针创建关联函数：
`ptr::null<T>() -> *const T` 创建一个0值的`*const T`，实际上就是 `0 as *const T`，用null()函数明显更符合程序员的习惯  
`ptr::null_mut<T>()->*mut T` 除了类型以外，其他同上  

`ptr::from_raw_parts<T: ?Sized>(data_address: *const (), metadata: <T as Pointee>::Metadata) -> *const T` 从内存地址和元数据创建裸指针 

`ptr::from_raw_parts_mut<T: ?Sized>(data_address: *mut (), metadata: <T as Pointee>::Metadata) -> *mut T` 功能同上，创建可变裸指针   

RUST裸指针类型转换时，经常使用以上两个函数获得需要的指针类型。

切片类型的裸指针创建函数如下：
`ptr::slice_from_raw_parts<T>(data: *const T, len: usize) -> *const [T] `  
`ptr::slice_from_raw_parts_mut<T>(data: *mut T, len: usize) -> *mut [T]` 由裸指针类型及切片长度获得切片类型裸指针，调用代码应保证data事实上就是切片的裸指针地址。由类型裸指针转换为切片类型裸指针最突出的应用之一是内存申请，申请的内存返回 * const u8的指针，这个裸指针是没有包含内存大小的，只有头地址，因此需要将这个指针转换为 * const [u8]，将申请的内存大小包含入裸指针结构体中。 
slice_from_raw_parts代码如下： 
```rust
pub const fn slice_from_raw_parts<T>(data: *const T, len: usize) -> *const [T] {
    //data.cast()将*const T转换为 *const()
    from_raw_parts(data.cast(), len)
}

pub const fn from_raw_parts<T: ?Sized>(
    data_address: *const (),
    metadata: <T as Pointee>::Metadata,
) -> *const T {
    //由以下代码可以确认 * const T实质就是PtrRepr类型结构体。
    unsafe { PtrRepr { components: PtrComponents { data_address, metadata } }.const_ptr }
}
```

#### 不属于方法的裸指针函数
`ptr::drop_in_place<T: ?Sized>(to_drop: *mut T)` 此函数是编译器实现的，用于由程序代码人工释放所有权，而不是交由RUST编译器处理。此函数会引发T内部成员的系列drop调用。

`ptr::metadata<T: ?Sized>(ptr: *const T) -> <T as Pointee>::Metadata `用来返回裸指针的元数据  

`ptr::eq<T>(a: *const T, b: *const T)->bool` 比较指针，此处需要注意，地址比较不但是地址，也比较元数据

ptr模块的函数大部分逻辑都比较简单。很多就是对intrinsic 函数做调用。

#### 裸指针类型转换方法
裸指针类型之间的转换：
`*const T::cast<U>(self) -> *const U ` ，本质上就是一个`*const T as *const U`。利用RUST的类型推断，此函数可以简化代码并支持链式调用。 
`*mut T::cast<U>(self)->*mut U` 同上。

调用以上的函数要注意，如果后继要把返回的指针转换成引用，那必须保证T类型与U类型内存布局完全一致。如果仅仅是将返回值做数值应用，则此约束可以不遵守，cast函数转换后的类型通常由编译器自行推断，有时需要仔细分析。  

裸指针与引用之间的类型转换：
```*const T::as_ref<`a>(self) -> Option<&`a T>``` 将裸指针转换为引用，因为*const T可能为零，所有需要转换为``Option<& `a T>``类型，转换的安全性由程序员保证，尤其注意满足RUST对引用的安全要求。这里要注意，转换后的生命周期实际上与原变量的生命周期相独立。因此，生命周期的正确性将由调用代码保证。  
```*mut T::as_ref<`a>(self)->Option<&`a T>```   同上
```*mut T::as_mut<`a>(self)->Option<&`a mut T>```同上，但转化类型为 &mut T。  

切片类型裸指针类型转换：
`ptr::*const [T]::as_ptr(self) -> *const T` 将切片类型的裸指针转换为切片成员类型的裸指针， 这个转换会导致指针的元数据丢失  
`ptr::*mut [T]::as_mut_ptr(self) -> *mut T` 同上

#### 裸指针结构体属性相关方法：
`ptr::*const T::to_raw_parts(self) -> (*const (), <T as super::Pointee>::Metadata)` 

`ptr::*mut T::to_raw_parts(self)->(* const (), <T as super::Pointee>::Metadata)`  由裸指针获得地址及元数据  
`ptr::*const T::is_null(self)->bool`  
`ptr::*mut T::is_null(self)->bool此`函数判断裸指针的地址值是否为0  

切片类型裸指针：
`ptr::*const [T]:: len(self) -> usize` 获取切片长度，直接从裸指针的元数据获取长度  
`ptr:: *mut [T]:: len(self) -> usize` 同上

#### 裸指针偏移计算相关方法
`ptr::*const T::offset(self, count:isize)->* const T` 得到偏移后的裸指针  
`ptr::*const T::wrapping_offset(self, count: isize) -> *const T` 考虑溢出绕回的offset  
`ptr::*const T::offset_from(self, origin: *const T) -> isize` 计算两个裸指针的offset值  
`ptr::*mut T::offset(self, count:isize)->* mut T` 偏移后的裸指针  
`ptr::*const T::wrapping_offset(self, count: isize) -> *const T` 考虑溢出绕回的offset  
`ptr::*const T::offset_from(self, origin: *const T) -> isize` 计算两个裸指针的offset值  
以上两个方法基本上通过intrinsic的函数实现

`ptr::*const T::add(self, count: usize) -> Self`   
`ptr::*const T::wraping_add(self, count: usize)->Self`  
`ptr::*const T::sub(self, count:usize) -> Self`  
`ptr::*const T::wrapping_sub(self, count:usize) -> Self`   
`ptr::*mut T::add(self, count: usize) -> Self`   
`ptr::*mut T::wraping_add(self, count: usize)->Self`  
`ptr::*mut T::sub(self, count:usize) -> Self`  
`ptr::*mut T::wrapping_sub(self, count:usize) -> Self`   
以上是对offset函数的包装，使之更符合语义习惯，并便于理解  

#### 裸指针直接赋值方法
```rust
    //该方法用于仅给指针结构体的 address部分赋值  
    pub fn set_ptr_value(mut self, val: *const u8) -> Self {
        // 以下代码因为只修改PtrComponent.address，所以不能直接用相等
        // 代码采取的方案是取self的可变引用，将此引用转换为裸指针的裸指针，
        let thin = &mut self as *mut *const T as *mut *const u8;
        // 这个赋值仅仅做了address的赋值，对于瘦指针，这个相当于赋值操作，
        // 对于胖指针，则没有改变胖指针的元数据。这种操作方式仅仅在极少数的情况下
        // 可以使用，极度危险。
        unsafe { *thin = val };
        self
    }
```
本节还有一部分裸指针方法没有介绍，留到mem模块分析完以后再介绍会更易于理解。 

### 裸指针小结
裸指针相关的代码多数比较简单，重要的是理解裸指针的概念，理解intrinsic 相关函数，这样才能够准确的理解代码。

#### RUST引用`&T`的安全要求
1. 引用的内存地址必须满足类型T的内存对齐要求
2. 引用的内存内容必须是初始化过的
举例：
 ```rust
    #[repr(packed)]
    struct RefTest {a:u8, b:u16, c:u32}
    fn main() {
        let test = RefTest{a:1, b:2, c:3};
        //下面代码编译会有告警，因为test.b 内存字节位于奇数，无法用于借用
        let ref1 = &test.b
    }
 ```
 编译器出现如下警告
 ```rust
 |
9 | let ref1 = &test.b;
  |            ^^^^^^^
  |
  = note: `#[warn(unaligned_references)]` on by default
  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
  = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>
  = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)
  = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)

 ```

## `MaybeUninit<T>`标准库代码分析
RUST对于变量的要求是必须初始化后才能使用，否则就会编译告警。但在程序中，总有内存还未初始化，但需要使用的情况：
1. 从堆申请的内存块，这些内存块都是没有初始化的
2. 需要定义一个新的泛型变量时，并且不合适用转移所有权进行赋值时
3. 需要定义一个新的变量，但希望不初始化便能使用其引用时
4. 定义一个数组，但必须在后继代码对数组成员初始化时
5. ...

为了处理这种需要在代码中使用未初始化内存的情况，RUST标准库定义了`MaybeUninit<T>`

### `MaybeUninit<T>`结构定义
源代码如下：
```rust
    #[repr(transparent)] 
    pub union MaybeUninit<T> {
        uninit: (),
        value: ManuallyDrop<T>,
    }
```
属性`repr(transparent)`实际上表示外部的封装结构在内存中等价于内部的变量,
`MaybeUninit<T>`的内存布局就是`ManuallyDrop<T>`的内存布局，从后文可以看到，`ManuallyDrop<T>`实际就是T的内存布局。所以`MaybeUninit<T>`在内存中实质也就是T类型。
`MaybeUninit<T>`容器来实现对未初始化变量的封装，以便在不引发编译错误完成对T类型未初始化变量的相关操作.
如果T类型的变量未初始化，那需要显式的提醒编译器不做T类型的drop操作，因为drop操作可能会对T类型内部的变量做连锁drop处理，从而引用未初始化的内容，造成UB(undefined behavior)。
RUST用`ManuallyDrop<T>`封装结构完成了对编译器的显式提示，对于用`ManuallyDrop<T>`封装的变量，生命周期终止的时候编译器不会调用drop操作。

### `ManuallyDrop<T>` 结构及方法
源代码如下：
```rust
#[repr(transparent)]
pub struct ManuallyDrop<T: ?Sized> {
    value: T,
}
```

重点关注的一些方法： 
`ManuallyDrop<T>::new（val:T) -> ManuallyDrop<T>`, 此函数返回ManuallyDrop变量拥有传入的T类型变量所有权，并将此块内存直接用ManuallyDrop封装, 对于val，编译器不再主动做drop操作。 
```rust
    pub const fn new(value: T) -> ManuallyDrop<T> {
        //所有权转移到结构体内部，value生命周期结束时不会引发drop
        ManuallyDrop { value }
    }
```  
`ManuallyDrop<T>::into_inner(slot: ManuallyDrop<T>)->T`, 将封装的T类型变量所有权转移出来，转移出来的变量生命周期终止时，编译器会自动调用类型的drop。  
```rust
    pub const fn into_inner(slot: ManuallyDrop<T>) -> T {
        //将value解封装，所有权转移到返回值中，编译器重新对所有权做处理
        slot.value
    }
```

`ManuallyDrop<T>::drop(slot: &mut ManuallyDrop<T>)`，drop掉内部变量，封装入`ManuallyDrop<T>`的变量一定是在程序运行的某一时期不需要编译器drop，所以调用这个函数的时候一定要注意正确性。 
`ManuallyDrop<T>::deref(&self)-> & T`, 返回内部包装的变量的引用 
```rust
    fn deref(&self) -> &T {
        //返回后，代码可以用&T对self.value做读操作,但不改变drop的规则
        &self.value
    }
```
`ManuallyDrop<T>::deref_mut(&mut self)-> & mut T`返回内部包装的变量的可变引用，调用代码可以利用可变引用对内部变量赋值，但不改变drop机制  

ManuallyDrop代码举例：
```rust
    use std::mem::ManuallyDrop;
    let mut x = ManuallyDrop::new(String::from("Hello World!"));
    x.truncate(5); // 此时会调用deref
    assert_eq!(*x, "Hello");
    // 但对x的drop不会再发生
```

#### `MaybeUninit<T>` 创建方法
`MaybeUninit<T>::uninit()->MaybeUninit<T>`, 可视为在栈空间上申请内存的方法，申请的内存大小是T类型的内存大小，该内存没有初始化。利用泛型和Union内存布局，RUST巧妙的利用此函数在栈上申请一块未初始化内存。此函数非常非常非常值得关注，在需要在栈空间定义一个未初始化泛型时，应第一时间想到`MaybeUninit::<T>::uninit()`。
```rust
    pub const fn uninit() -> MaybeUninit<T> {
        //变量内存布局与T类型完全一致
        MaybeUninit { uninit: () }
    }
```

`MaybeUninit<T>::new(val:T)->MaybeUninit<T>`, 内部用ManuallyDrop封装了val, 然后用MaybeUninit封装ManuallyDrop。因为如果T没有初始化过，调用这个函数会编译失败，所以此时内存实际上已经初始化过了。调用此函数要额外注意val的drop必须在后继有交代。
```rust
    pub const fn new(val: T) -> MaybeUninit<T> {
        //val这个时候是初始化过的。
        MaybeUninit { value: ManuallyDrop::new(val) }
    }
```
`MaybeUninit<T>::zeroed()->MaybeUninit<T>`, 申请了T类型内存并清零。 
```rust
    pub fn zeroed() -> MaybeUninit<T> {
        let mut u = MaybeUninit::<T>::uninit();
        unsafe {
            //因为没有初始化，所以不存在所有权问题，
            //必须使用ptr::write_bytes，否则无法给内存清0
            //ptr::write_bytes直接调用了intrinsics::write_bytes
            u.as_mut_ptr().write_bytes(0u8, 1);
        }
        u
    }
```
#### 对未初始化的变量赋值的方法
将值写入`MaybeUninit<T>`:
`MaybeUninit<T>::write(val)->&mut T`, 这个函数是在未初始化时使用，如果已经调用过write，且不希望解封装，那后继的赋值使用返回的&mut T。代码如下： 
```rust
    pub const fn write(&mut self, val: T) -> &mut T {
        //下面这个赋值，会导致原*self的MaybeUninit<T>的变量生命周期截止，会调用drop。但不会对内部的T类型变量做drop调用。所以如果*self内部的T类型变量已经被初始化且需要做drop，那会造成内存泄漏。所以下面这个等式实际上隐含了self内部的T类型变量必须是未初始化的或者T类型变量不需要drop。
        *self = MaybeUninit::new(val);
        // 函数调用后的赋值用返回的&mut T来做。
        unsafe { self.assume_init_mut() }
    }
```
#### 初始化后解封装的方法
用assume_init返回初始化后的变量并消费掉`MaybeUninit<T>`变量，这是最标准的做法：
`MaybeUninit<T>::assume_init()->T`,代码如下：
```rust
    pub const unsafe fn assume_init(self) -> T {
        // 调用者必须保证self已经初始化了
        unsafe {
            intrinsics::assert_inhabited::<T>();
            //把T的所有权返回，编译器会主动对T调用drop
            ManuallyDrop::into_inner(self.value)
        }
    }
```
assume_init_read是不消费self的情况下获得内部T变量，内部T变量的所有权已经转移到返回变量，后继要注意不能再次调用其他解封装函数。否则解封装后，会出现双份所有权，引发两次对同一变量的drop，导致UB。
```rust
    pub const unsafe fn assume_init_read(&self) -> T {
        
        unsafe {
            intrinsics::assert_inhabited::<T>();
            //会调用ptr::read
            self.as_ptr().read()
        }
    }
    //此函即ptr::read, 会复制一个变量，此时注意，实际上src指向的变量的所有权已经转移给了返回变量，
    //所以调用此函数的前提是src后继一定不能调用T类型的drop函数，例如src本身处于ManallyDrop，或后继对src调用forget，或给src绑定新变量。
    //在RUST中，不支持 let xxx = *(&T) 这种转移所有权的方式，因此对于只有指针输入，又要转移所有权的，智能利用浅拷贝进行粗暴转移。
    pub const unsafe fn read<T>(src: *const T) -> T {` 
        //利用MaybeUninit::uninit申请未初始化的T类型内存
        let mut tmp = MaybeUninit::<T>::uninit();
        unsafe {
            //完成内存拷贝
            copy_nonoverlapping(src, tmp.as_mut_ptr(), 1);
            //初始化后的内存解封装并返回
            tmp.assume_init()
        }
    }
```
与上个函数比较类似的`ManuallyDrop<T>::take`方法，用take函数将变量复制并获得变量的所有权。此时原变量仍然保留在ManuallyDrop中，后继不能再调用其他解封装函数，否则可能会出现UB。这里要特别注意理解take已经把变量的所有权转移到返回变量中。  
```rust
    pub unsafe fn take(slot: &mut ManuallyDrop<T>) -> T {
        // 拷贝内部变量，并返回内部变量的所有权
        // 返回后，原有的变量所有权已经消失，不能再用into_inner来返回
        // 否则会UB
        unsafe { ptr::read(&slot.value) }
    }

```
`MaybeUninit<T>::assume_init_drop(&self)` 对于已经初始化过的MaybeUninit<T>， 如果所有权一直没有转移，则必须调用此函数以触发T类型的drop函数完成所有权的释放。  
`MaybeUninit<T>::assume_init_ref(&self)->&T` 返回内部T类型变量的借用，调用者应保证内部T类型变量已经初始化，返回值按照一个普通的引用使用。应注意返回值的生命周期应该小于self的生命周期
`MaybeUninit<T>::assume_init_mut(&mut self)->&mut T`返回内部T类型变量的可变借用，调用者应保证内部T类型变量已经初始化，返回值按照一个普通的可变引用使用。应注意返回值的生命周期应该小于self的生命周期  

#### `MaybeUninit<[T]>`的方法
创建一个MaybeUninit的未初始化数组：
`MaybeUninit<T>::uninit_array<const LEN:usize>()->[Self; LEN]` 此处对LEN的使用方式需要注意，这是不常见的一个泛型写法,这个函数同样的申请了一块内存。代码： 
```rust
    pub const fn uninit_array<const LEN: usize>() -> [Self; LEN] {
        unsafe { MaybeUninit::<[MaybeUninit<T>; LEN]>::uninit().assume_init() }
    }
```
这里要注意区别数组类型和数组元素的初始化。对于数组`[MaybeUninit<T>;LEN]`这一类型本身来说，初始化就是确定整体的内存大小，所以数组类型的初始化在声明后就已经完成了。这时assume_init()是正确的。这是一个理解上的盲点。 

`MaybeUninit<T>::array_assume_init<const N:usize>(array: [Self; N]) -> [T; N]` 这个函数没有把所有权转移出来，代码分析如下：
```rust
    pub unsafe fn array_assume_init<const N: usize>(array: [Self; N]) -> [T; N] {
        unsafe {
            //最后调用是*const T::read()，此处 as *const _的写法可以简化代码,read后，所有权已经转移到返回值
            //返回后，此数组内所有的MaybeUninit变量成员不能再解封装
            (&array as *const _ as *const [T; N]).read()
        }
    }
```

#### MaybeUnint<T>典型案列
对T类型变量申请内存及赋值：
```rust
    use std::mem::MaybeUninit;

    // 获得一个未初始化的i32引用类型内存
    let mut x = MaybeUninit::<&i32>::uninit();
    // 将&0写入变量，完成初始化
    x.write(&0);
    // 将初始化后的变量解封装供后继的代码使用。
    let x = unsafe { x.assume_init() };
```
以上代码，编译器不会对x.write进行报警，这是`MaybeUninit<T>`的最重要的应用，这个例子展示了RUST如何给未初始化内存赋值的处理方式。调用assume_init前，必须保证变量已经被正确初始化。

更复杂的初始化例子：
```rust
    use std::mem::{self, MaybeUninit};
    
    let data = {
    // data在声明后实际上就已经初始化完毕。
    let mut data: [MaybeUninit<Vec<u32>>; 1000] = unsafe {
        //这里注意实际调用是MaybeUninit::<[MaybeUninit<Vec<u32>>;1000]>::uninit(), RUST的类型推断机制完成了泛型实例化
        MaybeUninit::uninit().assume_init()
    };
    
    for elem in &mut data[..] {
    elem.write(vec![42]);
    }
    
    // 直接用transmute完成整个数组类型的转换
    // 仔细思考一下，这里除了用transmute，似乎没有其他办法了，
    unsafe { mem::transmute::<_, [Vec<u32>; 1000]>(data) }
    };
    
    assert_eq!(&data[0], &[42]);
```

下面例子说明一块内存被 `MaybeUnint<T>`封装后，编译器将不再对其做释放，必须在代码中显式释放：
```rust
    use std::mem::MaybeUninit;
    use std::ptr;
   
    let mut data: [MaybeUninit<String>; 1000] = unsafe { MaybeUninit::uninit().assume_init() };
    // 初始化了500个String变量
    let mut data_len: usize = 0;
    for elem in &mut data[0..500] {
        //write没有将所有权转移出ManuallyDrop
        elem.write(String::from("hello"));
        data_len += 1;
    }
    //编译器无法自动调用drop释放String变量, 必须显式用drop_in_place释放
    for elem in &mut data[0..data_len] {
        //实际上也可以调用assume_init_drop来完成此工作
        unsafe { ptr::drop_in_place(elem.as_mut_ptr()); }
    }
```
上例中，在没有assume_init()调用的情况下，必须手工调用drop_in_place释放内存。
`MaybeUninit<T>`是一个非常重要的类型结构，未初始化内存是编程中不可避免要遇到的情况，`MaybeUninit<T>`也就是RUST编程中必须熟练使用的一个类型。

## 裸指针模块再分析
有了`MaybeUnint<T>`做基础后，可以对裸指针其他至关重要的标准库函数做出分析

`ptr::read<T>(src: *const T) -> T` 此函数在`MaybeUninit<T>`节中已经给出了代码，ptr::read是对所有类型通用的一种复制方法，需要指出，此函数完成浅拷贝，复制后，src指向的变量的所有权会转移至返回值。所以，调用此函数的代码必须保证src指向的变量生命周期结束后不会被编译器自动调用drop，否则可能导致重复drop，出现UB问题。  

`ptr::read_unaligned<T>(src: *const T) -> T`当数据结构中有未内存对齐的成员变量时，需要用此函数读取内容并转化为内存对齐的变量。否则会引发UB(undefined behaiver) 如下例： 

/// 从字节数组中读一个usize的值:
 ```rust
    use std::mem;
   
    fn read_usize(x: &[u8]) -> usize {
        assert!(x.len() >= mem::size_of::<usize>());
       
        let ptr = x.as_ptr() as *const usize;
        //此处必须用ptr::read_unaligned，因为不确定字节是否对齐
        unsafe { ptr.read_unaligned() }
    }
```
例子中，为了从byte串中读取一个usize，需要用read_unaligned来获取值，不能象C语言那样通过指针类型转换直接获取值。

`ptr::write<T>(dst: *mut T, src: T)` 代码如下：
```rust
pub const unsafe fn write<T>(dst: *mut T, src: T) {
    unsafe {
        //浅拷贝
        copy_nonoverlapping(&src as *const T, dst, 1);
        //必须调用forget，这里所有权已经转移。不允许再对src做drop操作
        intrinsics::forget(src);
    }
}
```
write函数本质上就是一个所有权转移的操作。完成src到dst的浅拷贝，然后调用了forget(src), 这使得src的Drop不再被调用。从而将所有权转移到dst。此函数是mem::replace， mem::transmute_copy的基础。底层由intrisic::copy_no_overlapping支持。 
这个函数中，如果dst已经初始化过，那原dst变量的所有权将被丢失掉，有可能引发内存泄漏。 

`ptr::write_unaligned<T>(dst: *mut T, src: T)` 与read_unaligned相对应。举例如下：
```rust
    #[repr(packed, C)]
    struct Packed {
        _padding: u8,
        unaligned: u32,
    }
    
    let mut packed: Packed = unsafe { std::mem::zeroed() };
    
    // Take the address of a 32-bit integer which is not aligned.
    // In contrast to `&packed.unaligned as *mut _`, this has no undefined behavior.
    // 对于结构中字节没有按照2幂次对齐的成员，要用addr_of_mut!宏来获得地址，无法用取引用的方式。
    let unaligned = std::ptr::addr_of_mut!(packed.unaligned);
    
    unsafe { std::ptr::write_unaligned(unaligned, 42) };
    
     assert_eq!({packed.unaligned}, 42); // `{...}` forces copying the field instead of creating a reference.
```
`ptr::read_volatile<T>(src: *const T) -> T`  是intrinsics::volatile_load的封装  
`ptr::write_volatile<T>(dst: *mut T, src:T)` 是intrinsics::volatiel_store的封装  

`ptr::macro addr_of($place:expr)` 因为用&获得引用必须是字节按照2的幂次对齐的地址，所以用这个宏获取非地址对齐的变量地址  
```rust
pub macro addr_of($place:expr) {
    //关键字是&raw const，这个是RUST的原始引用语义，但目前还没有在官方做公开。
    //区别与&, &要求地址必须满足字节对齐和初始化，&raw 则没有这个问题
    &raw const $place
}
```
`ptr::macro addr_of_mut($place:expr)` 作用同上。  
```rust
pub macro addr_of_mut($place:expr) {
    &raw mut $place
}
```
指针的通用函数请参考[Rust库函数参考](https://doc.rust-lang.org/core/ptr/index.html#functions)

## `NonNull<T>`代码分析
结构体定义如下：
```rust
#[repr(transparent)]
pub struct NonNull<T: ?Sized> {
    pointer: *const T,
}
```
属性`repr(transparent)`实际上表示外部的封装结构在内存中等价于内部的变量。`NonNull<T>`在内存中与`*const T`完全一致。可以直接转化为`* const T`。
裸指针的值因为可以为0，如果敞开来用，会有很多无法控制的代码隐患。按照RUST的习惯，标准库定义了非0的指针封装结构`NonNull<T>`，从而可以用`Option<NonNull<T>>`来对值可能为0的裸指针做出强制安全代码逻辑。不需要Option的则认为裸指针不会取值为0。
`NonNull<T>`本身是协变(covarient)类型.
**RUST中的协变，在RUST中，不同的生命周期被视为*不同的类型*，对于带有生命周期的类型变量做赋值操作时，仅允许子类型赋给基类型(长周期赋给短周期), 为了从基本类型生成复合类型的子类型和基类型的关系，RUST引入了协变性。从基本类型到复合类型的协变性有 协变(covarient)/逆变(contracovarient)/不变(invarient)三种**
程序员分析代码时，可以从基本类型之间的生命周期关系及协变性确定复合类型变量之间的生命周期关系，从而做合适的赋值操作。

因为`NonNull<T>`实际上是封装`* mut T`类型，但`* mut T` 与`NonNull<T>`的协变性不同，所以程序员如果不能确定需要协变类型，就不要使用`NonNull<T>`

### `NonNull<T>`创建关联方法
创建一个悬垂(dangling)指针, 保证指针满足类型内存对齐要求。该指针可能指向一个正常的变量，所以不能认为指向的内存是未初始化的。
```rust
    pub const fn dangling() -> Self {
        unsafe {
            //取内存对齐地址作为裸指针的地址。调用者应保证不对此内存地址进行读写
            let ptr = mem::align_of::<T>() as *mut T;
            NonNull::new_unchecked(ptr)
        }
    }
```
new函数，由输入的`*mut T`裸指针创建`NonNull<T>`。代码如下：
```rust
    pub fn new(ptr: *mut T) -> Option<Self> {
        if !ptr.is_null() {
            //ptr的安全性已经检查完毕
            Some(unsafe { Self::new_unchecked(ptr) })
        } else {
            None
        }
    }
```
```NonNull::<T>::new_unchecked(* mut T)->Self``` 用`* mut T`生成NonNull<T>，不检查`* mut T`是否为0，调用者应保证`* mut T`不为0。  
from_raw_parts函数，类似裸指针的from_raw_parts。  
```rust
    pub const fn from_raw_parts(
        data_address: NonNull<()>,
        metadata: <T as super::Pointee>::Metadata,
    ) -> NonNull<T> {
        unsafe {
            //需要先用from_raw_parts_mut形成* mut T指针
            NonNull::new_unchecked(super::from_raw_parts_mut(data_address.as_ptr(), metadata))
        }
    }
```
由From trait创建`NonNull<T>`
```rust
impl<T: ?Sized> const From<&mut T> for NonNull<T> {
    fn from(reference: &mut T) -> Self {
        unsafe { NonNull { pointer: reference as *mut T } }
    }
}

impl<T: ?Sized> const From<&T> for NonNull<T> {
    fn from(reference: &T) -> Self {
        //此处说明NonNull也可以接收不可变引用，不能后继将这个变量转换为可变引用
        unsafe { NonNull { pointer: reference as *const T } }
    }
}
```

### `NonNull<T>`类型转换方法
`NonNull<T>`的方法基本与`*const T/* mut T`相同，也容易理解，下文仅做罗列和简单说明
`NonNull::<T>::as_ptr(self)->* mut T` 返回内部的pointer 裸指针  
```NonNull::<T>::as_ref<'a>(&self)->&'a T ``` 返回的引用的生命周期与引用指向的变量生命周期无关，调用者应保证返回的引用的生命周期符合安全性要求
```NonNull::<T>::as_mut<'a>(&mut self)->&'a mut T``` 与 as_ref类似，但返回可变引用。  
```NonNull::<T>::cast<U>(self)->NonNull<U>``` 指针类型转换，程序员应该保证T和U的内存布局相同 

### `NonNull<[T]>` 方法
```NonNull::<[T]>::slice_from_raw_parts(data: NonNull<T>, len: usize) -> Self``` 将类型指针转化为类型的切片类型指针，实质是`ptr::slice_from_raw_parts`的一种包装。  
`NonNull::<[T]>::as_non_null_ptr(self) -> NonNull<T>` * const [T]::as_ptr的NonNull版本

### `NonNull<T>`的使用实例
以下的实例展示了 `NonNull<T>`在动态申请堆内存的使用：
```rust
    impl Global {
        fn alloc_impl(&self, layout: Layout, zeroed: bool) -> Result<NonNull<[u8]>, AllocError> {
            match layout.size() {
                0 => Ok(NonNull::slice_from_raw_parts(layout.dangling(), 0)),
                // SAFETY: `layout` is non-zero in size,
                size => unsafe {
                    //raw_ptr是 *const u8类型
                    let raw_ptr = if zeroed { alloc_zeroed(layout) } else { alloc(layout) };
                    //NonNull::new处理了raw_ptr为零的情况,返回NonNull<u8>,此时内存长度还与T不匹配
                    let ptr = NonNull::new(raw_ptr).ok_or(AllocError)?;
                    //将NonNull<u8>转换为NonNull<[u8]>, NonNull<[u8]>已经是类型T的内存长度。后继可以直接转换为T类型的指针了。这个转换极为重要。
                    Ok(NonNull::slice_from_raw_parts(ptr, size))
                },
            }
        }
        ....
    }
```
基本上，如果`* const T/*mut T`要跨越函数使用，或作为数据结构体的成员时，应将之转化成`NonNull<T>` 或`Unique<T>`。`*const T`应该仅仅保持在单一函数内。

#### `NonNull<T>` 与`MaybeUninit<T>`相关函数
```NonNull<T>::as_uninit_ref<`a>(&self) -> &`a MaybeUninit<T>``` NonNull与MaybeUninit的引用基本就是直接转换的关系，一体双面 
```rust
    pub unsafe fn as_uninit_ref<'a>(&self) -> &'a MaybeUninit<T> {
        // self.cast将NonNull<T>转换为NonNull<MaybeUninit<T>>
        //self.cast.as_ptr将NonNull<MaybeUninit<T>>转换为 *mut MaybeUninit<T>
        unsafe { &*self.cast().as_ptr() }
    }
``` 
```NonNull<T>::as_uninit_mut<`a>(&self) -> &`a mut MaybeUninit<T>```  
```NonNull<[T]>::as_uninit_slice<'a>(&self) -> &'a [MaybeUninit<T>]```  
```rust
    pub unsafe fn as_uninit_slice<'a>(&self) -> &'a [MaybeUninit<T>] {
        // 下面的函数调用ptr::slice_from_raw_parts
        unsafe { slice::from_raw_parts(self.cast().as_ptr(), self.len()) }
    }
```
```NonNull<[T]>::as_uninit_slice_mut<'a>(&self) -> &'a mut [MaybeUninit<T>]```   

## `Unique<T>` 代码分析
`Unique<T>`类型结构定义如下:
```rust
    #[repr(transparent)]
    pub struct Unique<T: ?Sized> {
        pointer: *const T,
        _marker: PhantomData<T>,
    }
```
和`NonNull<T>`对比，`Unique<T>`多了`PhantomData<T>`类型成员。这个定义使得编译器知晓，`Unique<T>`拥有了pointer指向的内存的所有权，`NonNull<T>`没有这个特性。具备所有权后，`Unique<T>`可以实现Send, Sync等trait。因为获得了所有权，此块内存无法用于他处，这也是Unique的名字由来原因.
指针在被`Unique<T>`封装前，必须保证是NonNull的。
对于RUST从堆内存申请的内存块，其指针都是用`Unique<T>`封装后来作为智能指针结构体内部成员变量，保证智能指针结构体拥有申请出来的内存块的所有权。

`Unique<T>`模块的函数及代码与`NonNull<T>`函数代码相类似，此处不分析。
`Unique::cast<U>(self)->Unique<U>` 类型转换，程序员应该保证T和U的内存布局相同  
`Unique::<T>::new(* mut T)->Option<Self>` 此函数内部判断* mut T是否为0值  
`Unique::<T>::new_unchecked(* mut T)->Self` 封装* mut T, 调用代码应该保证* mut T的安全性  
`Unique::as_ptr(self)->* mut T`  
`Unique::as_ref(&self)->& T` 因为Unique具备所有权，此处&T的生命周期与self相同，不必特别声明声明周期  
`Unique::as_mut(&mut self)->& mut T` 同上  

## mem模块函数  

### 泛型类型创建
`mem::zeroed<T>() -> T` 返回一个内存块清零的泛型变量，内存块在栈空间，代码如下：
```rust
pub unsafe fn zeroed<T>() -> T {
    // 调用代码必须确认T类型的变量可以取全零值
    unsafe {
        intrinsics::assert_zero_valid::<T>();
        MaybeUninit::zeroed().assume_init()
    }
}
```
`mem::uninitialized<T>() -> T` 返回一个未初始化过的泛型变量，内存块在栈空间。
```rust
pub unsafe fn uninitialized<T>() -> T {
    // 调用者必须确认T类型的变量允许未初始化的任意值
    unsafe {
        intrinsics::assert_uninit_valid::<T>();
        MaybeUninit::uninit().assume_init()
    }
}
```

### 泛型类型拷贝与替换 
`mem::take<T: Default>(dest: &mut T) -> T` 将dest设置为默认内容(不改变所有权)，用一个新变量返回dest的内容。这里有一个坑，即任何类型的default()必然能够满足多次drop不会出现内存安全问题。
```rust
pub fn take<T: Default>(dest: &mut T) -> T {
    //即mem::replace，见下文
    //此处，对于引用类型，编译器禁止用*dest来转移所有权，所以不能用let xxx = *dest; xxx这种形式返回T
    //其他语言简单的事情在RUST中必须用一个较难理解的方式来进行解决。replace()对所有权有仔细的处理
    replace(dest, T::default())
}
```
`mem::replace<T>(dest: &mut T, src: T) -> T` 用src的内容赋值dest(不改变所有权)，用一个新变量返回dest的内容。replace函数的难点在于了解所有权的转移。
```rust
pub const fn replace<T>(dest: &mut T, src: T) -> T {
    unsafe {
        //因为要替换dest, 所以必须对dest原有变量的所有权做处理，因此先用read将*dest的所有权转移到T，交由调用者进行处理, RUST不支持对引用类型做解引用的相等来转移所有权。将一个引用的所有权进行转移的方式只有粗暴的内存浅拷贝这种方法。
        //使用这个函数，调用代码必须了解T类型的情况，T类型有可能需要显式的调用drop函数。ptr::read前文已经分析过。
        let result = ptr::read(dest);
        //ptr::write本身会导致src的所有权转移到dest，后继不允许在src生命周期终止时做drop。ptr::write会用forget(src)做到这一点。
        ptr::write(dest, src);
        result
    }
}
```

`mem::transmute_copy<T, U>(src: &T) -> U` 新建类型U的变量，并把src的内容拷贝到U。调用者应保证T类型的内容与U一致，src后继的所有权问题需要做处理。
```rust
pub const unsafe fn transmute_copy<T, U>(src: &T) -> U {
    if align_of::<U>() > align_of::<T>() {
        // 如果两个类型字节对齐U 大于 T. 使用read_unaligned
        unsafe { ptr::read_unaligned(src as *const T as *const U) }
    } else {
        //用read即可完成
        unsafe { ptr::read(src as *const T as *const U) }
    }
}
```
#### 所有权转移的底层实现
所有权的本质是只能对变量做一次drop操作。变量的drop操作会引起变量结构体内部成员的链式drop。
所以，只要引发了变量的浅拷贝，所有权便被转移。原先放置变量的那块内存就必须被处理，forget及ManuallyDrop是两种典型方案。
不涉及裸指针的代码，一般不必考虑所有权必须人工处理的情况。但一旦涉及到裸指针，那就必须注意看是否出现了一个变量的双份或多份拷贝，每多一次拷贝，意味着编译器会对变量多做一次drop，触发UB。
##### 变量调用drop的时机
如下例子：
```rust
struct TestPtr {a: i32, b:i32}
impl Drop for TestPtr {
    fn drop(&mut self) {
        println!("{} {}", self.a, self.b);
    }
}
fn main() {
   let test = Box::new(TestPtr{a:1,b:2});
   let test1 = *test;
   let mut test2 = TestPtr{a:2, b:3};
   //此行代码会导致先释放test2拥有所有权的变量，然后再给test2赋值。代码后的输出会给出证据
   //将test1的所有权转移给test2，无疑代表着test2现有的所有权会在后继无法访问，因此drop被立即调用。
   test2 = test1;
   println!("{:?}", test2);
}
```
输出：
2 3
TestPtr { a: 1, b: 2 }
1 2

### 其他函数
`mem::forget<T>(t:T)` 通知RUST不做变量的drop操作  
```rust
pub const fn forget<T>(t: T) {
    //没有使用intrinsic::forget, 实际上效果一致，这里应该是尽量规避用intrinsic函数
    let _ = ManuallyDrop::new(t);
}
```
`mem::forget_unsized<T:Sized?>` 对intrinsics::forget的封装 
`mem::size_of<T>()->usize`/`mem::min_align_of<T>()->usize`/`mem::size_of_val<T>(val:& T)->usize`/`mem::min_align_of_val<T>(val: &T)->usize`/`mem::needs_drop<T>()->bool` 基本就是直接调用intrinsic模块的同名函数  
`mem::drop<T>(_x:T)` 释放内存  

## RUST堆内存申请及释放

### RUST类型系统的内存布局 
RUST提供了`Layout`内存布局类型, 此布局类型结构主要用于做堆内存申请。
`Layout`的数据结构如下：
```rust
pub struct Layout {
    // 类型需占用的内存大小，用字节数目表示
    size_: usize,
    //  按照此字节数目进行类型内存对齐， NonZeroUsize见代码后面文字分析
    align_: NonZeroUsize,
}
```
*`NonZeroUsize`是一种非0值的usize, 这种类型主要应用于不可取0的值，本结构中， 字节对齐属性变量不能被置0，所以用`NonZeroUsize`来确保安全性。如果用usize类型，那代码中就可能会把0置给align_，导致bug产生。这是RUST的一个设计规则，所有的约束要在类型定义即显性化，从而使bug在编译中就被发现。*

每一个RUST的类型都有自身独特的内存布局Layout。一种类型的Layout可以用`intrinsic::<T>::size_of()`及`intrinsic::<T>::min_align_of()`获得的类型内存大小和对齐来获得。
RUST的内存布局更详细原理阐述请参考[RUST内存布局] (https://doc.rust-lang.org/nomicon/data.html)，
Layout比较有典型意义的函数：
```rust
impl Layout {
    ...
    ...

    //array函数是计算n个T类型变量形成的数组所需的Layout，是从代码了解Rust Layout概念的一个好的实例
    //这里主要注意的是T类型的对齐会导致内存申请不是T类型的内存大小*n
    //而且对齐也是数组的算法
    pub fn array<T>(n: usize) -> Result<Self, LayoutError> {
        //获得n个T类型的内存Layout
        let (layout, offset) = Layout::new::<T>().repeat(n)?;
        debug_assert_eq!(offset, mem::size_of::<T>());
        //以完全对齐的大小  ，得出数组的Layout
        Ok(layout.pad_to_align())
    }

    //计算n个T类型需要的内存Layout, 以及成员之间的空间
    pub fn repeat(&self, n: usize) -> Result<(Self, usize), LayoutError> {
        // 所有的成员必须以成员的对齐大小来做内存对齐,首先计算对齐需要的padding空间
        let padded_size = self.size() + self.padding_needed_for(self.align());
        // 计算共需要多少内存空间，如果溢出，返回error
        let alloc_size = padded_size.checked_mul(n).ok_or(LayoutError)?;

        //由已经验证过得原始数据生成Layout，并返回单成员占用的空间
        unsafe { Ok((Layout::from_size_align_unchecked(alloc_size, self.align()), padded_size)) }
    }

    //填充以得到一个与T类型完全对齐的，最小的内存大小的Layout
    pub fn pad_to_align(&self) -> Layout {
        //得到T类型与对齐之间的空间大小
        let pad = self.padding_needed_for(self.align());
        // 完全对齐的大小
        let new_size = self.size() + pad;
        
        //以完全对齐的大小生成新的Layout
        Layout::from_size_align(new_size, self.align()).unwrap()
    }

    //计算T类型长度与完全对齐的差
    pub const fn padding_needed_for(&self, align: usize) -> usize {
        let len = self.size();

        // 实际上相当与C语言的表达式
        //   len_rounded_up = (len + align - 1) & !(align - 1);
        // 就是对对齐大小做除，如果有余数，商加1，是一种常用的方式.
        // 但注意，在rust中C语言的"+"等同于wrapping_add, C语言的“-”等同于
        // wrapping_sub
        let len_rounded_up = len.wrapping_add(align).wrapping_sub(1) & !align.wrapping_sub(1);
        //减去len，得到差值
        len_rounded_up.wrapping_sub(len)
    }

    //不检查输入参数，根据输入参数表示的原始数据生成Layout变量,调用代码应保证安全性
    pub const unsafe fn from_size_align_unchecked(size: usize, align: usize) -> Self {
        // 必须保证align满足不为0.
        Layout { size_: size, align_: unsafe { NonZeroUsize::new_unchecked(align) } }
    }

    //对参数进行检查，生成一个类型的Layout
    pub const fn from_size_align(size: usize, align: usize) -> Result<Self, LayoutError> {
        //必须保证对齐是2的幂次
        if !align.is_power_of_two() {
            return Err(LayoutError);
        }

        //满足下面的表达式，则size将不可能对齐 
        if size > usize::MAX - (align - 1) {
            return Err(LayoutError);
        }

        // 参数已经检查完毕.
        unsafe { Ok(Layout::from_size_align_unchecked(size, align)) }
    }
    ...
    ...
}
```

### `#[repr(transparent)]`内存布局模式
repr(transparent)用于仅包含一个成员变量的类型，该类型的内存布局与成员变量类型的内存布局完全一致。类型仅仅具备编译阶段的意义，在运行时，类型变量与其成员变量可以认为是一个相同变量，可以相互无障碍类型转换。使用repr(transparent)布局的类型基本是一种封装结构。

#### `#[repr(packed)]`内存布局模式
强制类型成员变量以1字节对齐，此种结构在协议分析和结构化二进制数据文件中经常使用

#### `#[repr(align(n))]` 内存布局模式
强制类型以2的幂次对齐

#### `#[repr(RUST)]`内存布局模式
默认的布局方式，采用此种布局，RUST编译器会根据情况来自行优化内存

#### `#[repr(C)]`内存布局模式
采用C语言布局方式， 所有结构变量按照声明的顺序在内存排列。默认4字节对齐。

### RUST堆内存申请与释放接口
资深的C/C++程序员都了解，在大型系统开发时，往往需要自行实现内存管理模块，以根据系统的特点优化内存使用及性能，并作出内存跟踪。
对于操作系统，内存管理模块更是核心功能。
对于C/C++小型系统，没有内存管理，仅仅是调用操作系统的内存系统调用，内存管理交给操作系统负责。操作系统内存管理模块接口是内存申请及内存释放的系统调用
对于GC语言，内存管理由虚拟机或语言运行时负责，利用语言提供的new来完成类型结构内存获取。
RUST的内存管理分成了三个界面：
1. 由智能指针类型提供的类型创建函数，一般有new, 与其他的GC类语言相同，同时增加了一些更直观的函数。
2. 智能指针使用实现Allocator Trait的类型做内存申请及释放。Allocator使用编译器提供的函数名申请及释放内存。
3. 实现了GlobalAlloc Trait的类型来完成独立的内存管理模块，并用#[global_allocator]注册入编译器，替代编译器默认的内存申请及释放函数。
这样，RUST达到了：
1. 对于小规模的程序，拥有与GC语言相类似的内存获取机制
2. 对于大型程序和操作系统内核，从语言层面提供了独立的内存管理模块接口，达成了将现代语法与内存管理模块共同存在，相互配合的目的。
但因为所有权概念的存在，从内存申请到转换为类型系统仍然还存在复杂的工作。
堆内存申请和释放的Trait GlobalAlloc定义如下:
```rust
pub unsafe trait GlobalAlloc {
    //申请内存，因为Layout中内存大小不为0，所以，alloc不会申请大小为0的内存
    unsafe fn alloc(&self, layout: Layout) -> *mut u8;
    //释放内存
    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout);
    
    //申请后的内存应初始化为0
    unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {
        let size = layout.size();
        let ptr = unsafe { self.alloc(layout) };
        if !ptr.is_null() {
            // 此处必须使用write_bytes，确保每个字节都清零
            unsafe { ptr::write_bytes(ptr, 0, size) };
        }
        ptr
    }

    //其他方法
    ...
    ...
}
```
在内核编程或大的框架系统编程中，开发人员通常开发自定义的堆内存管理模块，模块实现GlobalAlloc Trait并添加#[global_allocator]标识。对于用户态，RUST标准库有默认的GlobalAlloc实现。
```rust
extern "Rust" {
    // 编译器会将实现了GlobalAlloc Trait，并标记 #[global_allocator]的四个方法自动转化为以下的函数
    #[rustc_allocator]
    #[rustc_allocator_nounwind]
    fn __rust_alloc(size: usize, align: usize) -> *mut u8;
    #[rustc_allocator_nounwind]
    fn __rust_dealloc(ptr: *mut u8, size: usize, align: usize);
    #[rustc_allocator_nounwind]
    fn __rust_realloc(ptr: *mut u8, old_size: usize, align: usize, new_size: usize) -> *mut u8;
    #[rustc_allocator_nounwind]
    fn __rust_alloc_zeroed(size: usize, align: usize) -> *mut u8;
}

//对__rust_xxxxx_再次封装
pub unsafe fn alloc(layout: Layout) -> *mut u8 {
    unsafe { __rust_alloc(layout.size(), layout.align()) }
}

pub unsafe fn dealloc(ptr: *mut u8, layout: Layout) {
    unsafe { __rust_dealloc(ptr, layout.size(), layout.align()) }
}

pub unsafe fn realloc(ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {
    unsafe { __rust_realloc(ptr, layout.size(), layout.align(), new_size) }
}

pub unsafe fn alloc_zeroed(layout: Layout) -> *mut u8 {
    unsafe { __rust_alloc_zeroed(layout.size(), layout.align()) }
}

```
再实现Allocator Trait，对以上四个函数做封装处理。作为RUST其他模块对堆内存的申请和释放接口。

```rust
pub unsafe trait Allocator {
    fn allocate(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError>;

    fn allocate_zeroed(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError> {
        let ptr = self.allocate(layout)?;
        // SAFETY: `alloc` returns a valid memory block
        // 复杂的类型转换，实际是调用 *const u8::write_bytes(0, layout.size_)
        unsafe { ptr.as_non_null_ptr().as_ptr().write_bytes(0, ptr.len()) }
        Ok(ptr)
    }

    unsafe fn deallocate(&self, ptr: NonNull<u8>, layout: Layout);

    ...
}
```
Global 实现了 Allocator Trait。Rust大部分alloc库数据结构的实现使用Global作为Allocator。
```rust
unsafe impl Allocator for Global {
    fn allocate(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError> {
        //上文已经给出alloc_impl的说明
        self.alloc_impl(layout, false)
    }

    fn allocate_zeroed(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError> {
        self.alloc_impl(layout, true)
    }

    unsafe fn deallocate(&self, ptr: NonNull<u8>, layout: Layout) {
        if layout.size() != 0 {
            // SAFETY: `layout` is non-zero in size,
            // other conditions must be upheld by the caller
            unsafe { dealloc(ptr.as_ptr(), layout) }
        }
    }
    ...
    ...
}
```

Allocator使用GlobalAlloc接口获取内存，然后将GlobalAlloc申请到的* mut u8转换为确定大小的单一指针NonNull<[u8]>， 并处理申请内存可能出现的不成功。NonNull<[u8]>此时内存布局与 T的内存布局已经相同，后继可以转换为真正需要的T的指针并进一步转化为相关类型的引用，从而符合RUST类型系统安全并进行后继的处理。
以上是堆内存的申请和释放。 基于泛型，RUST也巧妙实现了栈内存的申请和释放机制 `mem::MaybeUninit<T>`

用Box的内存申请做综合举例：
```rust
    //此处A是一个A:Allocator类型
    pub fn try_new_uninit_in(alloc: A) -> Result<Box<mem::MaybeUninit<T>, A>, AllocError> {
        //实质是T类型的内存Layout
        let layout = Layout::new::<mem::MaybeUninit<T>>();
        //allocate(layout)?返回NonNull<[u8]>, NonNull<[u8]>::<MaybeUninit<T>>::cast()返回NonNull<MaybeUninit<T>>
        let ptr = alloc.allocate(layout)?.cast();
        //as_ptr 成为 *mut MaybeUninit<T>类型裸指针
        unsafe { Ok(Box::from_raw_in(ptr.as_ptr(), alloc)) }
    }
    
    pub unsafe fn from_raw_in(raw: *mut T, alloc: A) -> Self {
        //使用Unique封装* mut T，并拥有了*mut T指向的变量的所有权
        Box(unsafe { Unique::new_unchecked(raw) }, alloc)
    }
```
以上代码可以看到，NonNull<[u8]>可以直接通过cast 转换为NonNull<MaybeUninit<T>>, 这是另一种MaybeUninit<T>的生成方法，直接通过指针类型转换将未初始化的内存转换为MaybeUninit<T>。

## 小结
本章主要分析了RUST标准库内存相关模块， 内存相关模块代码多数不复杂，主要是要对内存块与类型系统之间的转换要有比较深刻的理解，并能领会在实际编码过程中在那些场景会使用内存相关的代码和API。RUST的内存安全给编码加了非常多的限制，有些时候这些限制只有通过内存API来有效的突破。如将引用指向的变量所有权转移出来的take函数。后继我们会看到几乎每个标准库的模块都大量的使用了ptr, mem模块中的方法和函数。只要是大型系统，不熟悉内存模块的代码，基本上无法做出良好的程序。
