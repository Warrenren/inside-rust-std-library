
## Cow写时复制结构解析

与Borrow Trait互为逆的ToOwned trait。 一般满足 T.borrow() 返回 &U，  U.to_owned()返回T
```rust
pub trait ToOwned {
    // 必须实现Borrow<Self> trait， Owned.borrow()->&Self
    type Owned: Borrow<Self>;

    // 从本类型生成Owned类型，一般由指针生成原始变量
    fn to_owned(&self) -> Self::Owned;
    
    //替换target的内容，原内容会被drop掉
    fn clone_into(&self, target: &mut Self::Owned) {
        *target = self.to_owned();
    }
}

impl<T> ToOwned for T
//实现了Clone的类型自然实现ToOwned
where
    T: Clone
{
    type Owned = T;
    fn to_owned(&self) -> T {
        //创建一个新的T类型的变量
        self.clone()
    }

    fn clone_into(&self, target: &mut T) {
        target.clone_from(self);
    }
}
```
Cow解决一类复制问题: 在与原有变量没有变化时使用原有变量的引用来访问变量，当发生变化时，完成对变量的复制生成新的变量。
```rust
pub enum Cow<'a, B: ?Sized + 'a>
where
    B: ToOwned,
{
    /// 用Borrowed封装原有变量的引用
    Borrowed( &'a B),

    ///当需要对原有变量做修改，会对原油变量调用to_owned得到新变量，然后用Owned进行封装
    Owned(<B as ToOwned>::Owned),
}
```
Cow的创建一般用`let a = Cow::Borrowed(&T)这种方式直接完成，因为是写时复制，所以需要用Borrowed()来得到初始值，否则不符合语义要求。

典型的trait实现：
```rust
//解引用，会返回&B
impl<B: ?Sized + ToOwned> const Deref for Cow<'_, B>
where
    B::Owned: ~const Borrow<B>,
{
    type Target = B;

    fn deref(&self) -> &B {
        match *self {
            //如果是原有的变量，则返回原有变量引用
            Borrowed(borrowed) => borrowed,
            //如果值已经被修改，则返回新变量的borrow()
            Owned(ref owned) => owned.borrow(),
        }
    }
}

//实现Borrow Trait
impl<'a, B: ?Sized> Borrow<B> for Cow<'a, B>
where
    B: ToOwned,
    <B as ToOwned>::Owned: 'a,
{
    fn borrow(&self) -> &B {
        //利用deref来返回
        &**self
    }
}

// Clone的实现，需要满足写时复制的要求。
impl<B: ?Sized + ToOwned> Clone for Cow<'_, B> {
    fn clone(&self) -> Self {
        match *self {
            //如果是原变量的引用，因为没有写，所以只需要复制一个引用即可
            Borrowed(b) => Borrowed(b),
            //如果已经对原变量做了复制，那需要再次复制x现有变量。
            //根据已知条件，只能先得到o的borrow()，即一个B的变量，然后调用B的to_owned获得O的拷贝
            Owned(ref o) => {
                let b: &B = o.borrow();
                Owned(b.to_owned())
            }
        }
    }

    fn clone_from(&mut self, source: &Self) {
        match (self, source) {
            //仅在双方都为Owned的情况下要先borrow后再复制，注意，此时self的原dest生命周期终止
            (&mut Owned(ref mut dest), &Owned(ref o)) => o.borrow().clone_into(dest),
            (t, s) => *t = s.clone(),
        }
    }
}
```
Cow<'a, T>的一些方法
```rust
impl<B: ?Sized + ToOwned> Cow<'_, B> {
    pub const fn is_borrowed(&self) -> bool {
        match *self {
            Borrowed(_) => true,
            Owned(_) => false,
        }
    }

    pub const fn is_owned(&self) -> bool {
        !self.is_borrowed()
    }

    //这个函数说明要对变量进行改变，因此，如果还是原变量的引用，则需要做复制操作
    pub fn to_mut(&mut self) -> &mut <B as ToOwned>::Owned {
        match *self {
            Borrowed(borrowed) => {
                //复制操作，复制原变量后，然后用Owned包装
                *self = Owned(borrowed.to_owned());
                match *self {
                    Borrowed(..) => unreachable!(),
                    Owned(ref mut owned) => owned,
                }
            }
            Owned(ref mut owned) => owned,
        }
    }

    //此函数也说明后继会修改，但会消费掉Cow
    pub fn into_owned(self) -> <B as ToOwned>::Owned {
        match self {
            Borrowed(borrowed) => borrowed.to_owned(),
            Owned(owned) => owned,
        }
    }
}

//由slice生成Cow的代码例
impl<'a, T: Clone> From<&'a [T]> for Cow<'a, [T]> {
    fn from(s: &'a [T]) -> Cow<'a, [T]> {
        //一般是先生成
        Cow::Borrowed(s)
    }
}
```
从Cow<'a, T>可以看到RUST基础语法的强大能力，大家可以思考一下如何用其他语言来实现这一写时复制的类型，会发现很难实现。
## Vec 分析
动态数组，结构体及创建，析构方法相关：
```rust
pub struct Vec<T, A: Allocator = Global> {
    //RawVec作为堆内存结构，RawVec的容量可能大于Vec的有效长度
    buf: RawVec<T, A>,
    //Vec中真正的成员数目，一般小于RawVec的容量
    len: usize,
}

macro_rules! vec {
    () => (
        $crate::vec::Vec::new()
    );
    ($elem:expr; $n:expr) => (
        $crate::vec::from_elem($elem, $n)
    );
    ($($x:expr),*) => (
        //首先生成Box<[T;N]>，然后利用slice的into_vec生成Vec<T>
        $crate::slice::into_vec(box [$($x),*])
    );
    //这里实际上就是完成($x,)=>$x。去掉了','号。 
    ($($x:expr,)*) => (vec![$($x),*])
}

impl<T, A: Allocator> ops::Deref for Vec<T, A> {
    type Target = [T];

    fn deref(&self) -> &[T] {
        //用裸指针类型变换方式形成切片的裸指针，再转换为切片引用
        unsafe { slice::from_raw_parts(self.as_ptr(), self.len) }
    }
}

impl<T, A: Allocator> ops::DerefMut for Vec<T, A> {
    fn deref_mut(&mut self) -> &mut [T] {
        unsafe { slice::from_raw_parts_mut(self.as_mut_ptr(), self.len) }
    }
}
//Vec<T>的Index下标实现,实际上就是切片Index实现
impl<T, I: SliceIndex<[T]>, A: Allocator> Index<I> for Vec<T, A> {
    type Output = I::Output;

    fn index(&self, index: I) -> &Self::Output {
        //&**self会将Vec转换为&[T]
        Index::index(&**self, index)
    }
}

impl<T, I: SliceIndex<[T]>, A: Allocator> IndexMut<I> for Vec<T, A> {
    fn index_mut(&mut self, index: I) -> &mut Self::Output {
        IndexMut::index_mut(&mut **self, index)
    }
}

impl<T> Vec<T> {
    pub const fn new() -> Self {
        //初始化buf为空
        Vec { buf: RawVec::NEW, len: 0 }
    }
    //其他创建函数，因为仅仅是对其他函数的封装调用，代码略
    pub fn with_capacity(capacity: usize) -> Self;
    pub unsafe fn from_raw_parts(ptr: *mut T, length: usize, capacity: usize) -> Self;
}

//由Box转换为Vec，这是RUST的最令人无语的地方，内存安全导致必须对类型做各种其他语言不需要的复杂的变换
pub fn into_vec<T, A: Allocator>(b: Box<[T], A>) -> Vec<T, A> {
    unsafe {
        let len = b.len();
        let (b, alloc) = Box::into_raw_with_allocator(b);
        Vec::from_raw_parts_in(b as *mut T, len, len, alloc)
    }
}

//所有支持SpecFromElem trait的类型可以直接转换生成n个初始值为elem的Vec动态数组
pub fn from_elem_in<T: Clone, A: Allocator>(elem: T, n: usize, alloc: A) -> Vec<T, A> {
    <T as SpecFromElem>::from_elem(elem, n, alloc)
}

pub(super) trait SpecFromElem: Sized {
    fn from_elem<A: Allocator>(elem: Self, n: usize, alloc: A) -> Vec<Self, A>;
}
//所有实现了Clone的类型自然支持SpecFromElem trait
impl<T: Clone> SpecFromElem for T {
    default fn from_elem<A: Allocator>(elem: Self, n: usize, alloc: A) -> Vec<Self, A> {
        //见下文分析
        let mut v = Vec::with_capacity_in(n, alloc);
        v.extend_with(n, ExtendElement(elem));
        v
    }
}
//drop方法
unsafe impl<#[may_dangle] T, A: Allocator> Drop for Vec<T, A> {
    fn drop(&mut self) {
        unsafe {
            //这里的drop_in_place调用会引发Vec<T>内部的成员变量自身的drop，所以只drop有意义的值
            //成员变量有些可能已经被释放过，会出现悬垂指针，所以用may_dangle来通知编译器
            ptr::drop_in_place(ptr::slice_from_raw_parts_mut(self.as_mut_ptr(), self.len))
        }
        //会自动调用RawVec的drop释放堆内存
    }
}

impl<T, A: Allocator> Vec<T, A> {
    //对RawVec做初始化，实际是空值
    pub const fn new_in(alloc: A) -> Self {
        Vec { buf: RawVec::new_in(alloc), len: 0 }
    }

    //具体见RawVec的函数说明，这里创建了一个容量为输入参数的RawVec,
    //但Vec本身的长度为0，标示成员都还没有初始化
    pub fn with_capacity_in(capacity: usize, alloc: A) -> Self {
        Vec { buf: RawVec::with_capacity_in(capacity, alloc), len: 0 }
    }

    //利用原始数据生成Vec，调用代码应该保证安全性：
    // *mut T应该是从堆申请的，符合RawVec<T>申请规则的大小和对齐，并且是用alloc来做的申请 
    pub unsafe fn from_raw_parts_in(ptr: *mut T, length: usize, capacity: usize, alloc: A) -> Self {
        unsafe { Vec { buf: RawVec::from_raw_parts_in(ptr, capacity, alloc), len: length } }
    }

    //生成原始数据，此处首先要使得self被禁止drop，
    //一般后继利用这些原始数据生成新的RawVec，重新启用新RawVec的Drop
    pub fn into_raw_parts(self) -> (*mut T, usize, usize) {
        let mut me = ManuallyDrop::new(self);
        //me自动解引用后得到Vec
        (me.as_mut_ptr(), me.len(), me.capacity())
    }

    //生成原始数据，包括alloc的变量
    pub fn into_raw_parts_with_alloc(self) -> (*mut T, usize, usize, A) {
        let mut me = ManuallyDrop::new(self);
        let len = me.len();
        let capacity = me.capacity();
        let ptr = me.as_mut_ptr();
        let alloc = unsafe { ptr::read(me.allocator()) };
        (ptr, len, capacity, alloc)
    }

    pub fn capacity(&self) -> usize {
        //RawVec的capacity
        self.buf.capacity()
    }
    pub fn allocator(&self) -> &A {
        self.buf.allocator()
    }
    pub fn len(&self) -> usize {
        self.len
    }
    //极度不安全，最好不要用这个函数改变len
    pub unsafe fn set_len(&mut self, new_len: usize) {
        debug_assert!(new_len <= self.capacity());

        self.len = new_len;
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
```
Vec容量相关方法：
```rust
    //在当前的len的基础上扩张输入的参数的内存容量
    //不一定会出发对内存的重新申请，因为RawVec的容量可能是够的
    //容量不能超出usize::MAX
    pub fn reserve(&mut self, additional: usize) {
        self.buf.reserve(self.len, additional);
    }

    //精确的扩张容量
    pub fn reserve_exact(&mut self, additional: usize) {
        self.buf.reserve_exact(self.len, additional);
    }

    //如果reserve不成功，返回错误类型
    pub fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError> {
        self.buf.try_reserve(self.len, additional)
    }

    //精确的容量
    pub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), TryReserveError> {
        self.buf.try_reserve_exact(self.len, additional)
    }

    //收缩内部buf容量到正好是Vec长度
    pub fn shrink_to_fit(&mut self) {
        if self.capacity() > self.len {
            self.buf.shrink_to_fit(self.len);
        }
    }

    //收缩容量
    pub fn shrink_to(&mut self, min_capacity: usize) {
        if self.capacity() > min_capacity {
            self.buf.shrink_to_fit(cmp::max(self.len, min_capacity));
        }
    }
    //在有变量存在的情况下做收缩
    pub fn truncate(&mut self, len: usize) {
        unsafe {
            if len > self.len {
                return;
            }
            //计算需要删除的容量
            let remaining_len = self.len - len;
            //形成需要删除的部分的切片类型
            let s = ptr::slice_from_raw_parts_mut(self.as_mut_ptr().add(len), remaining_len);
            //修改Vec的长度。
            self.len = len;
            //调用drop_in_place，使得切片能够对内部的成员调用drop以完成删除
            //注意，此时不涉及Vec内部的buf删除，仅仅是删除Vec的成员
            ptr::drop_in_place(s);
        }
    }
```
将Vec<T>转换成其他类型
```rust
    //转换为Box<[T], A>类型。
    pub fn into_boxed_slice(mut self) -> Box<[T], A> {
        unsafe {
            //此处重要，进入Box后，堆内存的容量必须是切片长度的内存，否则释放会引发问题
            self.shrink_to_fit();
            //本Vec的Drop需要禁止，由Box负责内存释放
            let me = ManuallyDrop::new(self);
            //这里将RawVec做了一个拷贝，实际上是将RawVec所有权转移出来，必须的
            //拷贝是效率高的做法
            let buf = ptr::read(&me.buf);
            let len = me.len();
            //用RawVec生成Box
            buf.into_box(len).assume_init()
        }
    }

    pub fn as_slice(&self) -> &[T] {
        //会自动解引用
        self
    }

    pub fn as_mut_slice(&mut self) -> &mut [T] {
        self
    }

    pub fn as_ptr(&self) -> *const T {
        let ptr = self.buf.ptr();
        unsafe {
            assume(!ptr.is_null());
        }
        ptr
    }

    pub fn as_mut_ptr(&mut self) -> *mut T {
        let ptr = self.buf.ptr();
        unsafe {
            assume(!ptr.is_null());
        }
        ptr
    }
```
插入与删除方法：
```rust
    //在index的位置插入一个变量
    pub fn insert(&mut self, index: usize, element: T) {
        #[cold]
        #[inline(never)]
        fn assert_failed(index: usize, len: usize) -> ! {
            panic!("insertion index (is {}) should be <= len (is {})", index, len);
        }
        //如果index大于len，出错
        let len = self.len();
        if index > len {
            assert_failed(index, len);
        }

        //如果预留的空间不够，则至少扩充1个成员空间
        if len == self.buf.capacity() {
            self.reserve(1);
        }

        unsafe {
            {
                //获得index的成员内存地址
                let p = self.as_mut_ptr().add(index);
                //此处将index之后所有成员内存向后偏移一个地址，最高的效率
                ptr::copy(p, p.offset(1), len - index);
                //将变量写入index的成员地址
                ptr::write(p, element);
            }
            //修改长度
            self.set_len(len + 1);
        }
    }

    pub fn remove(&mut self, index: usize) -> T {
        #[cold]
        #[inline(never)]
        #[track_caller]
        fn assert_failed(index: usize, len: usize) -> ! {
            panic!("removal index (is {}) should be < len (is {})", index, len);
        }

        //如果index大于Vec的长度，出错
        let len = self.len();
        if index >= len {
            assert_failed(index, len);
        }
        unsafe {
            let ret;
            {
                // 得到index的成员地址
                let ptr = self.as_mut_ptr().add(index);
                // 将成员变量拷贝出来，并转移了所有权
                ret = ptr::read(ptr);

                // 将index+1后的所有成员内存拷贝到前面一个地址
                ptr::copy(ptr.offset(1), ptr, len - index - 1);
            }
            //改变长度
            self.set_len(len - 1);
            //将删除的变量及所有权返回。
            ret
        }
    }

    //在尾部插入一个元素
    pub fn push(&mut self, value: T) {
        //如果预留空间不够，则扩充一个空间
        if self.len == self.buf.capacity() {
            self.reserve(1);
        }
        unsafe {
            //获取当前尾部成员后面的内存地址
            let end = self.as_mut_ptr().add(self.len);
            //将变量写入内存地址
            ptr::write(end, value);
            //长度加1
            self.len += 1;
        }
    }
     
    //取出尾部成员
    pub fn pop(&mut self) -> Option<T> {
        if self.len == 0 {
            None
        } else {
            unsafe {
                self.len -= 1;
                //将尾部成员变量读出并连同所有权共同返回，此处因为self.len已经减1，后继drop时不会再对
                //原尾部成员drop。所以尾部成员的所有权已经被处理掉了
                Some(ptr::read(self.as_ptr().add(self.len())))
            }
        }
    }

    //删除所有成员
    pub fn clear(&mut self) {
        //重用
        self.truncate(0)
    }
    
    //leak方法，此方法后，需要再次将返回值转换到RavVec，否则会内存泄漏
    pub fn leak<'a>(self) -> &'a mut [T]
    where
        A: 'a,
    {
        //本Vec变量不再被drop
        let mut me = ManuallyDrop::new(self);
        //生成可变切片引用，此引用没有后继处理的话会造成内存泄漏
        unsafe { slice::from_raw_parts_mut(me.as_mut_ptr(), me.len) }
    }
    ...
}
```
Vec<T>的所有难点实际上都在RUST的各种指针类型转换及内存读写的所有权处理上。这也是所有的RUST的数据结构基础类型实现上相对比其他语言需要额外理解的复杂之处。    

